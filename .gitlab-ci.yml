# KleverDesktop CI/CD configuration with signing, notarization, and release automation
# include:
#   - local: '.gitlab/ci-macos-signing.yml'

stages:
  - build
  - test
  - package
  - sign
  - release

variables:
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"
  # Apple signing related variables (configured in GitLab Settings > CI/CD > Variables)
  # APPLE_DEVELOPER_ID: "Developer ID Application: GRABTAXI HOLDINGS PTE. LTD. (VU3G7T53K5)"
  # APPLE_ID: Apple ID email for notarization
  # APPLE_APP_PASSWORD: App-specific password for notarization
  # APPLE_TEAM_ID: Team ID for notarization
  # APPLE_DEVELOPER_CERTIFICATE_P12: Base64 encoded Developer ID certificate
  
  # Dynamic version handling - for non-tag builds
  APP_VERSION: ${CI_COMMIT_TAG}
  # Windows build control - set to "true" to enable Windows builds
  WINDOWS_BUILD: "false"
  
  # Model configuration (will be used by the app on first run)
  # These can be overridden in GitLab CI/CD Settings > Variables if needed
  MODEL_TYPE: "Azure"
  OPENAI_API_MODEL: "gpt-4o"
  OPENAI_API_BASE: "https://public-api.grabgpt.managed.catwalk-k8s.stg-myteksi.com/v1/chat/completions"
  # OPENAI_API_KEY should be set in GitLab CI/CD Settings > Variables (masked and protected)
  TEMPERATURE: "0.0"
  MAX_TOKENS: "300"

# Use cache between builds
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .gradle/
    - build/

.gradle-job:
  image: eclipse-temurin:17-jdk
  before_script:
    - chmod +x ./gradlew
    # Get app version from Gradle if not using a tag
    - |
      if [ -z "$CI_COMMIT_TAG" ]; then
        export APP_VERSION=$(./gradlew -q printVersion --no-configuration-cache | tail -n 1)
        echo "Using version from Gradle: $APP_VERSION"
      else
        echo "Using tag as version: $CI_COMMIT_TAG"
      fi

build:
  extends: .gradle-job
  stage: build
  script:
    - ./gradlew build --no-daemon
  artifacts:
    paths:
      - app/build/
    expire_in: 1 week

test:
  extends: .gradle-job
  stage: test
  script:
    - ./gradlew test --no-daemon
  dependencies:
    - build
  artifacts:
    reports:
      junit: app/build/test-results/test/**/TEST-*.xml

package-mac:
  extends: .gradle-job
  stage: package
  tags:
    - macos
  script:
    - ./gradlew packageDmg
    # 빌드 단계에서 Gradle 버전 정보 저장
    - export BUILD_VERSION=$(./gradlew -q printVersion --no-configuration-cache | tail -n 1)
    - echo "BUILD_VERSION=$BUILD_VERSION" > build.info
  artifacts:
    paths:
      - app/build/compose/binaries/main/dmg
      - build.info
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == "internal-release"

package-windows:
  extends: .gradle-job
  stage: package
  tags:
    - windows
  script:
    - ./gradlew packageMsi
    # Add EXE packaging since it's referenced in the release
    - ./gradlew packageExe
  artifacts:
    paths:
      - app/build/compose/binaries/main/msi
      - app/build/compose/binaries/main/exe
  rules:
    - if: $CI_COMMIT_TAG && $WINDOWS_BUILD == "true"
    - if: $CI_COMMIT_BRANCH == "internal-release" && $WINDOWS_BUILD == "true"
  allow_failure: true

# Signing and notarization job directly in this file
sign-notarize-macos:
  stage: sign
  tags:
    - macos
  dependencies:
    - package-mac
  variables:
    # If CI_COMMIT_TAG is present, use it as version
    APP_VERSION: ${CI_COMMIT_TAG:-"1.0.2"}
  script: |
    # Gradle에서 빌드한 실제 버전 추출
    source build.info
    echo "Build version from Gradle: $BUILD_VERSION"
    
    # Debug information for version variables
    echo "DEBUG - CI_COMMIT_TAG: $CI_COMMIT_TAG"
    echo "DEBUG - APP_VERSION: $APP_VERSION"
    
    # Gradle이 생성한 DMG 파일 경로 설정
    export DMG_INPUT_PATH="app/build/compose/binaries/main/dmg/KleverDesktop-$BUILD_VERSION.dmg"
    export DMG_OUTPUT_PATH="app/build/compose/binaries/main/dmg/KleverDesktop-$BUILD_VERSION-signed.dmg"
    
    echo "Using input DMG: $DMG_INPUT_PATH"
    
    # DMG 파일 존재 확인
    if [ ! -f "$DMG_INPUT_PATH" ]; then
      echo "DMG file not found at path: $DMG_INPUT_PATH"
      echo "Searching for generated DMG file..."
      FOUND_DMG=$(find app/build/compose/binaries/main/dmg -name "*.dmg" | head -n 1)
      if [ ! -z "$FOUND_DMG" ]; then
        echo "Found DMG at: $FOUND_DMG"
        DMG_INPUT_PATH="$FOUND_DMG"
        
        # 파일명에서 버전 추출 (예: app/build/compose/binaries/main/dmg/KleverDesktop-1.0.2.dmg -> 1.0.2)
        FILENAME=$(basename "$FOUND_DMG")
        BUILD_VERSION=$(echo $FILENAME | sed 's/KleverDesktop-\(.*\)\.dmg/\1/')
        echo "Extracted version from filename: $BUILD_VERSION"
      else
        echo "No DMG file found. Build failed."
        exit 1
      fi
    fi
    
    echo "Running signing and notarization process..."
    chmod +x build-mac.sh
    ./build-mac.sh
    
    # create dist directory and copy DMG file
    echo "Creating versioned copies of DMG files..."
    mkdir -p dist
    
    # Important: Create a single DMG file for the tag version (to avoid upload size limit)
    # Clean up previous copies
    rm -f dist/*.dmg
    
    # Use a definite version for the file name
    TAG_VERSION="${CI_COMMIT_TAG:-$BUILD_VERSION}"
    echo "Using version for artifact: $TAG_VERSION"
    
    # Copy the tag version
    cp "$DMG_INPUT_PATH" "dist/KleverDesktop-${TAG_VERSION}.dmg"
    echo "Created single artifact file: dist/KleverDesktop-${TAG_VERSION}.dmg"
  artifacts:
    paths:
      # Use the same definite version reference in artifacts
      - dist/KleverDesktop-${CI_COMMIT_TAG:-*}.dmg
    expire_in: 1 month
  rules:
    - if: $CI_COMMIT_TAG

# Publish package to GitLab Package Registry
publish-package:
  stage: release
  image: curlimages/curl:latest
  needs:
    - sign-notarize-macos
  script: |
    echo "Publishing DMG file to GitLab Package Registry..."
    TAG_VERSION="${CI_COMMIT_TAG}"
    DMG_PATH="dist/KleverDesktop-${TAG_VERSION}.dmg"
    
    # Check if DMG file exists
    if [ -f "$DMG_PATH" ]; then
      echo "Found DMG at: $DMG_PATH"
      # Compute file size using Alpine-compatible stat command
      FILE_SIZE=$(stat -c%s "$DMG_PATH")
      echo "File size: $FILE_SIZE bytes"
      
      # Upload the package to GitLab Package Registry
      echo "Uploading to Package Registry..."
      curl --header "JOB-TOKEN: $CI_JOB_TOKEN" \
           --upload-file "$DMG_PATH" \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/kleverdesktop/${TAG_VERSION}/KleverDesktop-${TAG_VERSION}.dmg"
      
      echo "Package published successfully!"
      echo "Download URL: ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/kleverdesktop/${TAG_VERSION}/KleverDesktop-${TAG_VERSION}.dmg"
    else
      echo "DMG file not found at: $DMG_PATH"
      find dist -type f -name "*.dmg"
      exit 1
    fi
  artifacts:
    paths:
      - dist/KleverDesktop-${CI_COMMIT_TAG}.dmg
  rules:
    - if: $CI_COMMIT_TAG

# Create GitLab release when a tag is pushed
release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - publish-package
  script: 'echo "Creating release for $CI_COMMIT_TAG" && echo "Job ID: $CI_JOB_ID" && ls -la dist/'
  release:
    name: "Release $CI_COMMIT_TAG"
    description: |
      KleverDesktop Release $CI_COMMIT_TAG (macOS only build)
      
      ## Downloads
      
      The application can be downloaded from:
      - GitLab Package Registry
      - Job Artifacts
    tag_name: $CI_COMMIT_TAG
    assets:
      links:
        - name: "KleverDesktop-macOS.dmg (Package Registry)"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/kleverdesktop/${CI_COMMIT_TAG}/KleverDesktop-${CI_COMMIT_TAG}.dmg"
          link_type: package
        - name: "KleverDesktop-macOS.dmg (Job Artifacts)"
          url: "${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/raw/dist/KleverDesktop-${CI_COMMIT_TAG}.dmg"
          link_type: other
  rules:
    - if: $CI_COMMIT_TAG
